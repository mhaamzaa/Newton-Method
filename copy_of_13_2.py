# -*- coding: utf-8 -*-
"""Copy of 13.2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/187JYA1Ee6SyyBlWh0ynhc_ka03-Lzo0W

# Problem 13.2
"""

import numpy as np

"""# Problem Parameters and Equation"""

"""
    N = Quantity of Nuclei
    No = Initial Quantity of Nuclei
    T_Half = Half life of radioactive substance
    t = time
    lambda = Decay Constant
"""
T_Half = 19
No = 10**4
N = 444
lambda1 = (np.log(2))/(T_Half)

def function(t):
    return N - No*(np.exp(-lambda1*t))

# Derivative of function(t)
def function_prime(t):
    return lambda1*No*(np.exp(-lambda1*t))

"""# Newton's Method"""

def newton(f,fprime,x0,epsilon=1.0e-6, LOUD=False):
    """Find the root of the function f via Newton-Raphson method
    Args:
        f: function to find root of
        fprime: derivative of f
        x0: initial guess
        epsilon: tolerance
    Returns:
        estimate of root
    """
    x = x0
    if (LOUD):
        print("x0 =",x0)
    iterations = 0
    fx = f(x)
    while (np.fabs(fx) > epsilon):
        fprimex = fprime(x)
        if (LOUD):
            print("x_",iterations+1,"=",x,"-",fx,
                 "/",fprimex,"=",x - fx/fprimex)
        x = x- fx/fprimex
        iterations += 1
        fx = f(x)
    print("It took",iterations,"iterations")
    return x #return estimate of root

root = newton(function,function_prime,50,LOUD = True)
print("The time it will take to get specific activity of",N,"Bq/Kg is",root,"days.");

"""# Inexact Newton Method"""

def inexact_newton(f,x0,delta = 1.0e-7, epsilon=1.0e-6, LOUD=False):
    """Find the root of the function f via Newton-Raphson method
    Args:
        f: function to find root of
        x0: initial guess
        delta: finite difference parameter
        epsilon: tolerance
    Returns:
        estimate of root
    """
    x = x0
    if (LOUD):
        print("x0 =",x0)
    iterations = 0
    fx = f(x)
    while (np.fabs(fx) > epsilon):
        fxdelta = f(x+delta)
        slope = (fxdelta - fx)/delta
        if (LOUD):
            print("x_",iterations+1,"=",x,"-",fx,"/",slope,"=",
                 x - fx/slope)
        x = x - fx/slope
        fx = f(x)
        iterations += 1
    print("It took",iterations,"iterations")
    return x #return estimate of root

root1 = inexact_newton(function,50,LOUD = True)
print("The time it will take to get specific activity of",N,"Bq/Kg is",root1,"days.");

"""# Secant Method"""

def secant(f,x0,delta = 1.0e-7, epsilon=1.0e-6, LOUD=False):
    """Find the root of the function f via Newton-Raphson method
    Args:
        f: function to find root of
        x0: initial guess
        delta: finite difference parameter
        epsilon: tolerance
    Returns:
        estimate of root
    """
    x = x0
    if (LOUD):
        print("x0 =",x0)
    #first time use inexact Newton
    x_old = x
    fold = f(x_old)
    fx = fold
    slope = (f(x_old+delta) - fold)/delta
    x = x - fold/slope
    if (LOUD):
        print("Inexact Newton\nx_",1,"=",x,"-",fx,"/",slope,"=",
             x - fx/slope,"\nStarting Secant")
    fx = f(x)
    iterations = 1
    while (np.fabs(fx) > epsilon):
        slope = (fx - fold)/(x - x_old)
        fold = fx
        x_old = x
        if (LOUD):
            print("x_",iterations+1,"=",x,"-",fx,
                 "/",slope,"=",x - fx/slope)
        x = x - fx/slope
        fx = f(x)
        iterations += 1
    print("It took",iterations,"iterations")
    return x #return estimate of root

root2 = secant(function,50,LOUD = True)
print("The time it will take to get specific activity of",N,"Bq/Kg is",root2,"days.");

"""# Problem 12.2"""

import numpy as np

"""# Problem Parameters and Equation"""

"""
    N = Quantity of Nuclei
    No = Initial Quantity of Nuclei
    T_Half = Half life of radioactive substance
    t = time
    lambda = Decay Constant
"""
T_Half = 19
No = 10**4
N = 444
lambda1 = (np.log(2))/(T_Half)

def function(t):
    return N - No*(np.exp(-lambda1*t))

"""# Bisection Method"""

def bisection(f,a,b,epsilon=1.0e-6):
    """Find the root of the function f via bisection
    where the root lies within [a,b]
    Args:
        f: function to find root of
        a: left-side of interval
        b: right-side of interval
        epsilon: tolerance
    Returns:
        estimate of root
    """
    assert (b>a)
    fa = f(a)
    fb = f(b)
    assert (fa*fb < 0)
    delta = b - a
    print("We expect",
          int(np.ceil(np.log(delta/epsilon)/np.log(2))),"iterations")
    iterations = 0
    while (delta > epsilon):
        c = (a+b)*0.5
        fc = f(c)
        if (fa*fc < 0):
            b = c
            fb = fc
        elif (fb*fc < 0):
            a = c
            fa = fc
        else:
            return c
        delta = b-a
        iterations += 1
    print("It took",iterations,"iterations")
    return c #return midpoint of interval

root = bisection(function,0,100)
print("The time it will take to get specific activity of",N,"Bq/Kg is",root,"days.");

"""# False Position Method"""

def false_position(f,a,b,epsilon=1.0e-6):
    """Find the root of the function f via false position
    where the root lies within [a,b]
    Args:
        f: function to find root of
        a: left-side of interval
        b: right-side of interval
        epsilon: tolerance
    Returns:
        estimate of root
    """
    assert (b>a)
    fa = f(a)
    fb = f(b)
    assert (fa*fb< 0)
    delta = b - a
    iterations = 0
    residual = 1.0
    while (np.fabs(residual) > epsilon):
        m = (fb-fa)/(b-a)
        c = a - fa/m
        fc = f(c)
        if (fa*fc < 0):
            b = c
            fb = fc
        elif (fb*fc < 0):
            a = c
            fa = fc
        else:
            print("It took",iterations,"iterations")
            return c
        residual = fc
        iterations += 1
    print("It took",iterations,"iterations")
    return c #return c

root1 = false_position(function,0,100)
print("The time it will take to get specific activity of",N,"Bq/Kg is",root1,"days.");

"""# Ridder's Method"""

def ridder(f,a,b,epsilon=1.0e-6):
    """Find the root of the function f via Ridderâ€™s Method
    where the root lies within [a,b]
    Args:
        f: function to find root of
        a: left-side of interval
        b: right-side of interval
        epsilon: tolerance
    Returns:
        estimate of root
    """
    assert (b>a)
    fa = f(a)
    fb = f(b)
    assert (fa*fb < 0)
    delta = b - a
    iterations = 0
    residual = 1.0
    while (np.fabs(residual) > epsilon):
        c = 0.5*(b+a)
        d = 0.0
        fc = f(c)
        if (fa - fb > 0):
            d = c + (c-a)*fc/np.sqrt(fc**2-fa*fb)
        else:
            d = c - (c-a)*fc/np.sqrt(fc**2-fa*fb)
            fd = f(d)
        #now see which part of interval root is in
        if (fa*fd < 0):
            b = d
            fb = fd
        elif (fb*fd < 0):
            a = d
            fa = fd
        residual = fd
        iterations += 1
    print("It took",iterations,"iterations")
    return d #return c

root2 = ridder(function,0,100)
print("The time it will take to get specific activity of",N,"Bq/Kg is",root,"days.");